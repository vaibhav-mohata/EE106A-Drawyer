import numpy as np
# from path_draw import draw_paths
# import rospy
#from intera_interface import gripper as robot_gripper   

# dataflow for this module will look like this
# (1) numpy array from picture module                                   --DONE
# (2) numpy array -> DFS -> list of paths                               --DONE
# (3) list of paths -> formatting -> list of path coords                --IP (will be this code)
# (4) list of path coords -> sawyer path                                --IP (hopefully lab 7 satisfies)

# def gripper_setup():
#     right_gripper = robot_gripper.Gripper('right_gripper')
#     print('Calibrating...')
#     right_gripper.calibrate()
#     rospy.sleep(2.0)

#     input("Press enter if ready to close")
#     # Close the right gripper
#     print('Closing...')
#     right_gripper.close()
#     rospy.sleep(1.0)
#     return    

LIMIT_NUMBER_FOR_DFS = 7



"""
projects a 2D image onto 3D page, returning the 3D path coords
input: numpy array of 1s and 0s (generated by the camera module)
output: A list of 3D paths
"""
def array_to_path(image):
    #gripper_setup()
    # DFS on the image array for list of 2D paths
    paths = dfs(image)
    print("2D image paths:\n", paths, "\n")

    # image characteristics
    image_width, image_height = image.shape

    # page characteristics
    #corner_coord_down = (.726997, -0.362929, 0.0867994) # manual calibration
    corner_coord_down = (0.626868, -0.198411, -0.026)
    paper_len_x = .457 # 45.7cm
    paper_len_x = .305 # 45.7cm
    paper_len_y = .305 # 30.5cm

    # pixel resolution using characteristics
    x_res = paper_len_x / image_width
    y_res = paper_len_y / image_height

    # lift the pen to not mark page
    lift_dist = .025
    corner_coord_up = (corner_coord_down[0], corner_coord_down[1], corner_coord_down[2] + lift_dist) # manual calibration

    # to be populated by triples (paths -> path coords)
    paths_coords = []
    for path in paths:
        path_coords = []
        path_coords.append(to3D(path[0], corner_coord_up, x_res, y_res))
        for point in path:
            path_coords.append(to3D(point, corner_coord_down, x_res, y_res)) ### TODO add pen lifts ###
        path_coords.append(to3D(path[-1], corner_coord_up, x_res, y_res))
        if len(path_coords) >= LIMIT_NUMBER_FOR_DFS:
            paths_coords.append(path_coords)

    return paths_coords


def to3D(point, corner_coord, x_res, y_res):
    return (corner_coord[0] + point[0] * x_res, corner_coord[1] + point[1] * y_res, corner_coord[2])

"""
inputs: a numpy array
outputs: a 2D list of paths
"""
def dfs(image):
    image_width, image_height = image.shape
    paths = []
    unexplored = True
    while unexplored:
        unexplored = False
        # for each pixel in image
        for x in range(image_width):
            for y in range(image_height):
                # if pixel on
                if image[x][y] == 1:
                    unexplored = True
                    # add this pixel and neighbors to path
                    path = visit(image, x, y)
                    paths.append(path)
    return paths

"""
explore a point on the image array
"""
def visit(image, x, y):
    image_width, image_height = image.shape
    # add and turn off this pixel
    points = [(x, y)]
    image[x][y] = 0

    # For each of the 4 neighbors...
    neighbors = [(x, y + 1), (x + 1, y), (x - 1, y), (x , y - 1)]
    for x, y in neighbors:
        # Don't check pixels outside borders
        if x >= image_width or x < 0 or y >= image_height or y < 0:
            continue
        # Add recursive neighbors to path
        if image[x][y] == 1:
            points.extend(visit(image, x, y))
            return points
    return points

def main(image):
    rospy.init_node('draw_node')
    arrays_image = array_to_path(image)
    print("here")
    print(arrays_image)
    draw_paths(arrays_image)


if __name__ == '__main__':
    # rospy.init_node('draw_node')
    image = np.random.choice([0,1], size = (5,5), p = [1./3, 2./3])
    print(image, "\n")
    # image = np.asarray([(1, 1, 1, 1, 1), (1, 0, 0, 0, 1), (1, 0, 0, 0, 1), (1, 0, 0, 0, 1), (1, 1, 1, 1, 1)])
    main(image)